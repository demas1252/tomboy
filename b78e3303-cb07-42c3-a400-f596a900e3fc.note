<?xml version="1.0" encoding="utf-8"?>
<note version="0.3" xmlns:link="http://beatniksoftware.com/tomboy/link" xmlns:size="http://beatniksoftware.com/tomboy/size" xmlns="http://beatniksoftware.com/tomboy">
  <title>Наследование в ООП</title>
  <text xml:space="preserve"><note-content version="0.1"><link:internal>Наследование</link:internal> в ООП


     <link:url>http://blogs.gotdotnet.ru/personal/bezzus/PermaLink.aspx?guid=CE75349<link:broken>C</link:broken></link:url><link:url>-2F95-4624-8B2<link:broken>C</link:broken></link:url><link:url>-F54450AA64D6</link:url>
     
     Бытует мнение, <link:internal>что ООП</link:internal> базируется на трех функциональных возможностях: <link:internal>наследование</link:internal>, инкапсуляция и полиморфизм. Фактически это стало определением <link:internal>ООП</link:internal>, ввиду отсутствия формального "официального" определения. Однако, если обратиться к первоисточникам, то там фигурируют совсем другие конструкции.. В частности, у Алана Кея, который считается "папой" <link:internal>ООП</link:internal>, упоминаются сообщения и состояние, а вот с наследованием у него определенно бедулька, хотя к полиморфизму и инкапсуляции, как конкретным реализациям, его трактовку <link:internal>ООП</link:internal> вполне можно свести...
     Если же подробненько все поисследовать, то можно прийти к логичному заключению, что <link:internal>наследование</link:internal> в ООП, на самом деле, выполняет лишь вспомогательную роль и служит для обеспечения полиморфизма в статически типизированных языках.
     С другой стороны, когда <link:internal>ООП</link:internal> стал проникать в мэйнстрим и получать физическое воплощение в реальных языках, оборудованных наследованием, народ решил упомянутое <link:internal>наследование</link:internal> использовать и как средство для избегания дублирования кода. Таким образом, <link:internal>наследование</link:internal> можно (и нужно) разделить на два вида, а именно <link:internal>наследование</link:internal> контрактов и <link:internal>наследование</link:internal> реализаций.
     Как должно быть очевидно, <link:internal>наследование</link:internal> контрактов служит исконной <link:internal>цели</link:internal> <link:internal>ООП</link:internal> - обеспечению полиморфизма, <link:internal>наследование</link:internal> же реализаций помогает повторно использовать тщательно написанный код.
     Теперь самое время разобрать оба вида наследования по отдельности..
     
     *<link:internal>Наследование</link:internal> реализаций:*
Частенько это довольно удобная штука, на первый взгляд, однако она оборудована достаточно большим количеством подвохов и пользуясь ей, надо осознавать на что идешь.
- Сильная связность. Класс наследник не может защититься от базового никаким формальным контрактом, любое изменение реализации базового класса автоматически отражается на всех наследниках и их работа может сломаться, даже если код наследников не трогался. <link:internal>Наследование</link:internal> вообще самая сильная связь между классами, в языках, в которых нет классов-"друзей".
- Опять-таки, в следствии сильной связности, <link:internal>наследование</link:internal> реализаций жестко связывает абстракцию и собственно реализацию, что далеко не всегда удобно.
- При использовании наследования реализаций, очень легко нарушить LSP (принцип подстановки имени Вари Лисков), не получится использовать любой класс-наследник вместо базового.
- При использовании иерархии класов внешним кодом, есть опасность неявно завязаться на конкретную реализацию базового класса, не задекларированную в публичном контракте, в следствии чего, при изменении реализации базового класса, сломается не только код классов-наследников, но и внешний код.
- Глядя на публичный контракт класса нельзя сказать, что за методы он реализует и где именно будет производиться обработка - унаследованные методы не видны в коде класса.
В следствии вышеописанных причин, <link:internal>наследование</link:internal> реализаций рекомендуется использовать только в тех случаях, когда четко представляешь что и ради чего делаешь, и не рекомендуется использвать развесистые иерархии классов. Тем более, что для избегания дублирования кода, есть масса других способов... Даже в GoF, большинство паттернов направлено, в том числе, и на уменьшение иерархии наследования.

     *<link:internal>Наследование</link:internal> контрактов:*
     
Эта штука, как уже говорилось ранее, предназначена для обеспечения ad-hoc полиморфизма с минимумом побочных эффектов - реализуя единый контракт в разных классах по разному, получаем разное поведение. Если же говорить об <link:internal>ООП</link:internal>, как подходе к проектированию, то оперирование формальными контрактами, заставляет двигаться в верном направлении - при проектировании класса не надо думать что он будет в себе содержать, надо думать, как его будут использовать. С этой точки зрения <link:internal>наследование</link:internal> реализаций таит в себе еще один подвох - <link:internal>проектирование</link:internal> в терминах реализаций может привести к построению весьма загадочных и трудно сопровождаемых конструкций.
Известный идеолог <link:internal>ООП</link:internal> - Беня Мейер (Bertrand Meyer) исповедует и продвигает подход к проектированию под названием Design by Contract, который, если по простому, и заключается в том, чтобы на первом этапе расписать все в контрактах, а потом уже заниматься их изнурительной реализацией. И, надо заметить, что подобный подход дает весьма неплохие результаты.
Но и тут не все гладко. Обратной стороной использования формальных контрактов, является необходимость тщательно следить и продумывать эти самые контракты. Любое изменение контракта приводит к необходимости менять все классы, реализующие этот контракт. Если разрабатывается конечный продукт, то это не страшно и даже полезно, в конце-концов обилие средств рефаторинга, наличие статически типизированного компилятора и доступность исходников способно избавить от этой проблемы, однако при разработке библиотек, тут можно хорошо встрять.

В целом, <link:internal>наследование</link:internal> контрактов - рулит, а без наследования реализаций можно вполне обойтись. Некоторые ортодоксы от прогрессизма призывают вообще отказаться от наследования реализаций... Но наверное было бы правильнее разрешать <link:internal>наследование</link:internal> только после явной декларации (делать все классы по умолчанию sealed, в терминах <link:broken>C</link:broken>#). Строго говоря, для того, чтобы от класса можно было безопасно наследоваться, его надо для этого нарошным образом задизайнить, а уж если пришлось напрячься, с проектированием, то не сложно и разрешить наследоваться явно... </note-content></text>
  <last-change-date>2009-10-12T12:00:26.4278780+04:00</last-change-date>
  <last-metadata-change-date>2009-10-12T12:00:26.4278780+04:00</last-metadata-change-date>
  <create-date>2008-03-27T22:09:08.9099480+03:00</create-date>
  <cursor-position>47</cursor-position>
  <width>450</width>
  <height>360</height>
  <x>5</x>
  <y>70</y>
  <open-on-startup>False</open-on-startup>
</note>