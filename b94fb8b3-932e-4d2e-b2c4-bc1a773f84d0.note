<?xml version="1.0" encoding="utf-8"?>
<note version="0.3" xmlns:link="http://beatniksoftware.com/tomboy/link" xmlns:size="http://beatniksoftware.com/tomboy/size" xmlns="http://beatniksoftware.com/tomboy">
  <title>Описание работы система при отключенном MTS</title>
  <text xml:space="preserve"><note-content version="0.1">Описание работы система при отключенном MTS


Обновление этой таблицы (опять таки – в старых версиях DAX), организовано следующим образом: При любых модификациях таблицы складских проводок (<link:internal>inventTrans</link:internal>), система находит (или создает) соответствующую запись в таблице запасов в наличии и затем обновляет в ней количество. Естественно – при обновлении записи, до завершения транзакции, обновившей таковую, любой доступ к ней (и по чтению и по записи) из других соединений блокируется. (Случай Dirty Read не рассматриваем). Если у нас не используется учет по партиям или серийным номерам, то с некоторой долей приближения можно сказать, что если мы в транзакции изменили складскую проводку по некоторой номенклатуре и складу, то до конца этой транзакции, пользователи с других рабочих станций  НЕ МОГУТ выполнять какие-то операции по данной номенклатуре на данном складе. Делается это по той простой причине, что до успешного завершения (или отмены) операции, остаток на складе представляет собой некоторую вероятностную величину. Давайте представим себе ситуацию, при которой подобных блокировок не происходит. Допустим - у нас на складе лежит 40 штук некого артикула. Кладовщик в данный момент проводит приходную отборочную накладную с еще 800 штуками. Два сейла резервируют по 20 и 40 штук соответственно. Другой кладовщик оформляет расходную отборочную накладную на 15 штук. Возникает вопрос - сколько у нас вообще на складе свободного товара и можно ли дать третьему сейлу зарезервировать под свой заказ еще 60 штук ? (Кстати – во всем дальнейшем изложении подразумевается , что режим отрицательного склада отключен.)

Таким образом – ситуация блокировок складских остатков не объясняется  чисто технической проблемой скверной реализации контроля складского остатка. Эта проблема вытекает из самой сущности транзакционной модели работы с данными. Если в ходе транзакции у нас происходит модификация уровня некоторого критического ресурса (в нашем случае – складского остатка), то до конца транзакции, доступ к информации по уровню этого ресурса должен быть заблокирован для других соединений, чтобы избежать ситуации, грубо говоря, “продажи двух билетов на одно место”.  Даже если бы у нас появилась какая-то сверхбыстрая СУБД, которая позволяла бы мгновенно считать остатки на основании самих складских проводок (без таблицы запасов в наличии), мы столкнулись бы с той же проблемой:  Мы не смогли бы понять – нужно ли добавлять к сумме текущего остатка складские проводки, модифицированные в ходе незавершенных транзакций других сессий.

Для того чтобы оценить масштабы бедствия с блокировками, давайте рассмотрим другой пример:

Допустим кладовщик начали оформление приходной отборочной накладной на 120 позиций. Первые 40 позиций были благополучно  получены, заблокировав информацию по остаткам по этой номенклатуре  от всех остальных пользователей. Добравшись до 41 позиции, разноска отборочной накладной  остановилась и стала ждать пока остаток по номенклатуре из 41 позиции будет освобожден первым сейлом, который в данный момент оформляет накладную из 8 позиций. В свою очередь этот первый сейл, который уже заблокировал 6 номенклатур, ждет освобождения 7ой, которая в этот момент заблокирована вторым сейлом. Второй сейл в свою очередь тоже ждет освобождения какой-то номенклатуры, заблокированной вторым кладовщиком, который оформляет отборочную накладную на списание. Второй кладовщик в свою очередь ждет освобождения артикула, заблокированного третьим сейлом и тд. В результате - все 4 участника процесса ждут окончания операции третьего сейла. После того как она будет закончена, цепочка будет медленно и печально разворачиваться в обратную сторону, и у кладовщика N <link:internal>1</link:internal> спустя какое-то время наконец-то будет получена  очередная строка, конечно если всем повезет, и не выяснится что артикул из 8ой позиции , создаваемого первым сейлом оказался заблокирован сейлом N 4.  При этом нужно помнить, что все участники забега уже заблокировали какие-то остатки, соответственно - есть шансы что их тоже кто-то ждет. Из за этого время выполнения логистической операции с парочкой номенклатур может колебаться от долей секунды, до нескольких минут. От реальной производительности сервера БД или сервера приложений  это время мало зависит. Просто в зависимости от того как легла карта, очередь за ресурсом может состоять из одного человека, а может и из 10… Кстати - возможно многие видели, иногда появляющееся  в DAX сообщение о том что сессия была закрыта из за “Тупиковой ситуации”. Время от времени возникают ситуации, при которых в списке ожидания образуются циклы, например, выясняется что сейл N4 которого ждет кладовщик  N2, на самом деле сам ждет освобождения артикула заблокированного первым кладовщиком   в начале процесса получения товара. В подобной ситуации система просто принудительно закрывает соединение последнего из участников очереди, отменяя начатые им операции и выдавая ему сообщение о тупиковой ситуации. Причем если в момент такого массового ожидания очереди на блокировку посмотреть на загрузку серверов, то выяснится что и сервер БД и AOS, скорее всего не очень-то и сильно загружены. Вот именно этот момент обычно и вызывает наибольшее недоумение системных администраторов. Как же так – сервера не загружены, а система так медленно работает ? Причем покупка значительно более мощного сервера БД, не решит проблему, поскольку производительность системы в данной ситуации определяется производительностью всей цепочки сервер БД-Сервер AOS-клиентский компьютер (причем с учетом задержек в <link:internal>сети</link:internal>). И если проапгрейдить сервера за разумные деньги еще можно, то апгрейд всех клиентских компьютеров и повышение производительности всех сетевых соединений может обойтись  в совсем запредельную сумму.</note-content></text>
  <last-change-date>2009-07-05T15:29:12.0133350+04:00</last-change-date>
  <last-metadata-change-date>2009-07-05T15:29:12.0133350+04:00</last-metadata-change-date>
  <create-date>2008-03-29T06:26:12.4905780+03:00</create-date>
  <cursor-position>72</cursor-position>
  <width>450</width>
  <height>360</height>
  <x>4</x>
  <y>661</y>
  <open-on-startup>False</open-on-startup>
</note>