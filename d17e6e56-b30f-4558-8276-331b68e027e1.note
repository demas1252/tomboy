<?xml version="1.0" encoding="utf-8"?>
<note version="0.3" xmlns:link="http://beatniksoftware.com/tomboy/link" xmlns:size="http://beatniksoftware.com/tomboy/size" xmlns="http://beatniksoftware.com/tomboy">
  <title>Селективность индекса</title>
  <text xml:space="preserve"><note-content version="0.1">Селективность индекса


Пример1: пусть NUM_ROWS=100 DISTINCT_KEYS=2, тогда селективность индекса будет 50% - индекс в общем случае не нужен.
Пример2: пусть NUM_ROWS=1000 DISTINCT_KEYS=2, селективность индекса попрежнему будет 50% - индекс в общем случае не нужен.
Пример3: пусть NUM_ROWS=100 DISTINCT_KEYS=100 (твой случай!!!), тогда селективность индекса будет 1% - индекс в общем случае нужен.


У индекса, строго говоря, нет селективности, она бывает именно у предикатов. Но иногда, для краткости изложения, "селективностью индекса" называют селективность предиката типа index_key_field=&lt;ключевое значение&gt; поскольку это наиболее селективный возможный предикат при доступе по индексу, и соответственно если уж тут селективность плохая, то при прочих она будет вообще никакой.

При такой трактовке "Селективностью индекса", при равномерном распределении данных, будет отношение числа строк соответствующих конкретному ключевому значению к общему числу строк в индексе. т.е.
    sel = ( NUM_ROWS/DISTINCT_KEY) / NUM_ROWS = 1/DISTINCT_KEY ,
как вам уже было ранее сказано, т.е. если в индексе всего 3 различных значения, то и селективность при доступе по равенству ключу будет ваша любимая 1/3.

Но если мы попадаем в ситуацию с неравномерным распределением данных, такой подход вообще не применим. Допустим есть всего 2 значения ключего поля 1 и 0, distinct_key=2, но со значением 1 у нас 99% записей, а со значением 0 - 1%. Тогда для доступа по предикату key = 0 индекс будет вполне оправдан, хотя селективность посчитанная по формуле выше будет аж 0,5 .

По вашей изначальной формуле вы имеете обратную картину, чем больше DISTINCT_KEYS тем более близкое значение к 1-це вы получаете.  Например , для первичных ключей (как вам уже намекали) distinct_keys=num_rows ( каждое значение уникально и неповторяется), и по вашей формуле селективность будет 1, значительно больше 0.33 и по вашей логике надо их удалять.

См. также 
<link:internal>Предикаты по Function-Based индексу</link:internal></note-content></text>
  <last-change-date>2009-01-10T19:15:44.3431680+03:00</last-change-date>
  <last-metadata-change-date>2009-01-10T19:15:44.3431680+03:00</last-metadata-change-date>
  <create-date>2008-03-29T06:47:55.7885720+03:00</create-date>
  <cursor-position>1913</cursor-position>
  <width>447</width>
  <height>561</height>
  <x>1120</x>
  <y>148</y>
  <open-on-startup>False</open-on-startup>
</note>