<?xml version="1.0" encoding="utf-8"?>
<note version="0.3" xmlns:link="http://beatniksoftware.com/tomboy/link" xmlns:size="http://beatniksoftware.com/tomboy/size" xmlns="http://beatniksoftware.com/tomboy">
  <title>Телега о кластерном индексе</title>
  <text xml:space="preserve"><note-content version="0.1">Телега о кластерном индексе


По неизвестной мне причине, казалось бы уже миллион раз поднятый и разобранный вопрос о правильном использовании кластерного индекса поднимается вновь и вновь, и, что самое удивительное, наружу выплывают все те же старые мифы...

1. Кластерный индекс физически упорядочивает записи, строго в порядке определяемом ключевыми полями индекса.

2. Кластерный индекс черезвычайно дорог при вставке и изменении.

3. Кластерный индекс обязательно должен быть построен по Primary Key, причем, лучше всего, если этот PK является Identity столбцом.

 

Попытаюсь в очередной раз развеять эти заблуждения.

1.  Если дословно перевести фразу из BOL относительно физического упорядочивания, то выглядеть она будет примерно так: «... кластерный индекс определяет физический порядок данных в таблице...», но там не сказано как именно определяет. А еще точнее было бы сказать «...влияет на физический порядок...».

Теперь разберемся как именно влияет. Как известно, в <link:internal>MSSQL</link:internal>’е данные хранятся по странично, индекс представляет собой B+tree и размер одного узла индекса равен одной странице. Страницы образуют двунаправленый связный список, иными словами, в заголовке каждой страницы есть указатель на предыдущую и следующую страницы, какая предыдущая, а какая следующая определяется сортировкой по ключу индекса. Физически же страницы могут располагаться как угодно! Новые страницы спокойно добавятся на свободное место, ни какого перемещения страниц не происходит, как многие думают, меняются лишь указатели.

Далее записи внутри страницы. Отличительной особенностью B+Tree является наличие ссылок друг на друга между ключами на самом нижнем уровне, то есть все ключи на листьевых узлах так же образуют связанный список, отсортированный в порядке возрастания или убывания ключа. Соответственно необходимости именно в физическом упорядочивании записей внутри страницы так же нет, внутри страницы записи так же упорядочены всего лишь логически, убедиться в этом омжно с помощю такого не хитрого эксперимента:

Создадим табличку в одну страницу с кластерным индексом:

create table t(a int)

insert into t(a) values(100)
insert into t(a) values(200)
insert into t(a) values(300)
insert into t(a) values(400)

create clustered index ix on t(a)

-- выясним что получилось...
--

dbcc traceon(3604)
declare @<link:internal>db</link:internal>_id int, @tbl_id int 
select @<link:internal>db</link:internal>_id = <link:internal>db</link:internal>_id('Cavy'), @tbl_id = object_id('t') 
dbcc tab(@<link:internal>db</link:internal>_id, @tbl_id)

-- PageFID PagePID     IAMFID IAMPID      ObjectID    IndexID PageType IndexLevel NextPageFID NextPagePID PrevPageFID PrevPagePID 
-- ------- ----------- ------ ----------- ----------- ------- -------- ---------- ----------- ----------- ----------- ----------- 
-- 1       19544       NULL   NULL        853578079   1       10       0          0           0           0           0
-- 1       19543       1      19544       853578079   0       1        0          0           0           0           0
-- 1       19545       1      19544       853578079   1       2        0          0           0           0           0

Первую страницу я выделил, смотрим что там:

dbcc page('Cavy', 1, 19543, 3)

-- Slot 0 Offset 0x60
-- a                                = 100              

-- Slot 1 Offset 0x6b
-- a                                = 200              

-- Slot 2 Offset 0x76
-- a                                = 300              

-- Slot 3 Offset 0x81
-- a                                = 400

Обратите внимание на параметр Offset — физический адрес — пока все по честному, адреса подряд.
А теперь поизмываемся:

delete from t where a = 200
insert into t (a) values(250)

-- и посмотрим что произошло
-- 
dbcc page('Cavy', 1, 19543, 3)

-- Slot 0 Offset 0x60
-- a                                = 100              

-- Slot 1 Offset 0x8<link:internal>c</link:internal>
-- a                                = 250              

-- Slot 2 Offset 0x76
-- a                                = 300              

-- Slot 3 Offset 0x81
-- a                                = 400

Логически записи по прежнему отсортированы — Slot 0, Slot 1, ect... А вот физически запись 250 разместилась не по адресу 0x6b, где была раньше 200, ну или по крайней мере не между 0x60 и 0x76, а по адресу 0x8<link:internal>c</link:internal>, то есть добавилась в конец страницы.

 

Таким образом, физически накладывается лишь одно ограничение – запись должна находится на определенной странице для того, чтобы при сканировании диапазона серверу не пришлось прыгать из середины страницы  за следующей записью, а потом возвращаться на эту же страницу. Например, записи со значениями в ключевом поле 1, 2 и 3 никогда не расположатся так, что 1 и 3 будут на одной странице, а 2 на следующей. Либо 1 и 2 на одной странице (в любом физическом порядке) и 3 на другой либо 1 на одной, а 2 и 3 на следующей.

 

Следовательно можно частично развеять 2й миф.

2. Вставка и изменение по ключевым полям кластерного индекса операция, безусловно, не самая дешевая, но и не такая дорогая как почему-то принято считать. Как видно из предыдущих пояснений требования к физическому порядку не столь строги и, следовательно, <link:internal>накладные расходы</link:internal> на обеспечение оного значительно ниже.

 

3. На этом пункте хотелось бы остановиться по подробнее...

Во всех книгах по <link:internal>MSSQL</link:internal>’ю, в том числе и в BOL прямым текстом пишут, что кластерный индекс наиболее эффективен при выборке по диапазону. Учитывая, что в большинстве случаев PK – это суррогатный ключ, сложно представить диапазонную выборку по нему, ведь такой PK не имеет никакой семантики и диапазонная выборка будет практически случайной. Откуда же тогда берется миф о том, что кластерный индекс должен быть по PK и именно по суррогатному (IDENTITY)? Сие великая тайна есть...

Смоделируем некоторую абстрактную ситуацию: Есть менеджеры, каждый из которых обслуживает заказы своих клиентов, периодически к ним обращаясь. Заказов очень много, менеджер, как правило, работает с группой заказов, выборки частые и много запросов на обновление - работа ведется очень интенсивная. Надо оптимизировать обращение менеджеров к заказам. Есть табличка менеджеров, в которой нас будет интересовать PK – ID_Manager и есть табличка заказов, в которой нас будет интересовать ID_Order (PK - ID заказа, суррогат Identity) и ID_Manager (FK ссылка на таблицу менеджеров). Возможные варианты построение индексов на табличке Orders (заказов).

1) ID_Order – кластерный индекс, ID_Manager – обычный.

Напоминаю условия задачи, менеджер работает только со своими заказами, во всех запросах к заказам ID_Manager присутствует и это диапазонные <link:internal>запросы</link:internal>, так как менеджер работает сразу с несколькими заказами.

Что происходит при очередной выборке заказов менеджером в данном случае. Сначала, по ID_Manager находятся ID_Order нужных заказов, не все заказы целиком, а только их ID. А далее, за каждым заказом будет обращение отдельно, по этому самому ID. При этом заказы будут располагаться физически в разных частях таблицы, то есть, это random access и разные менеджеры будут обращаться к одним и тем же страницам данных в поисках своих заказов.

(Небольшое лирическое отступление: совсем недавно на одном из форумов в похожей ситуации народ наперебой советовал делать кластерный ID_Order, совершенно ни чем не аргументируя, кроме как абстактным «так правильно, меня слушай», что собственно и побудило меня к написанию данного текста)

2) Казалось бы кощунственное, на первый взгляд решение, сделать кластерным FK – ID_Manager, что это даст?

По ID_Manager будут выбираться заказы целиком, без лишнего вычисления ID_Order, что сэкономит как минимум одно обращение к диску на каждый заказ.

Доступ к заказам будет последовательный, то есть сервер спустится по индексу до листьевого узла, а дальше просто будет читать записи с заказами подряд переходя по ссылкам на следующую запись, что намного эффективнее случайного чтения заказов.

Менеджеры практически не будут физически пересекаться по заказам на страницах данных.

Сервер получит возможность в полной мере использовать оптимизации типа Read Ahead, что дает хороший эффект на больших объемах данных.

Суммарный выигрыш в производительности от такого использования кластерного индекса может быть больше чем на порядок.

 

Так же не следует забывать еще один момент, при добавлении ключа индекса на короткий промежуток времени накладывается монопольная блокировка (latch) на страницу в которую идет добавление. Обычно это практически не оказывает влияния на производительность, но в случае кластерного индекса по identity столбцу все новые записи будут попадать  на последнюю страницу и при очень интенсивной вставке из параллельных транзакций это может привести к тому, что последняя страница окажется перманантно заблокированной, что не окажет положительного влияния на эффективность вставки.

 

Мораль же такова, что при выборе кластерного индекса следует всегда думать, а не идти слепо на поводу EM, который по умолчанию делает кластерный индекс на PK. Как показывает практика кластерный индекс на PK, особенно если это суррогат, крайне редко оказывается самым оптимальным решением.</note-content></text>
  <last-change-date>2009-09-24T14:37:01.2001120+04:00</last-change-date>
  <last-metadata-change-date>2009-09-24T14:37:01.2001120+04:00</last-metadata-change-date>
  <create-date>2008-03-30T17:30:45.3620090+04:00</create-date>
  <cursor-position>273</cursor-position>
  <width>954</width>
  <height>737</height>
  <x>4</x>
  <y>260</y>
  <open-on-startup>False</open-on-startup>
</note>