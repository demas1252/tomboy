<?xml version="1.0" encoding="utf-8"?>
<note version="0.3" xmlns:link="http://beatniksoftware.com/tomboy/link" xmlns:size="http://beatniksoftware.com/tomboy/size" xmlns="http://beatniksoftware.com/tomboy">
  <title>firstonly - firstfast</title>
  <text xml:space="preserve"><note-content version="0.1">firstonly - firstfast

Часто в коде встречается, имеется в виду стандартный функционал без местных модификаций

select firstOnly ... &lt;Table&gt;

что подразумевает, что из таблицы мы хотим получить ТОЛЬКО первую запись, и как при любом запросе, чем быстрее, тем лучше.
Возникает логичный вопрос, а почему не используется запись вида, —

select firstOnly firstFast ... &lt;Table&gt;

ведь в этом случае первая запись должна появиться быстрее, чем в случае указанном немного выше. Поправте меня, если я не прав.

AndyD
Для <link:internal>MS SQL</link:internal> эти хинты преобразуются в OPTION(FAST n). По скорости примерно одинаково.

---

Из книги: <link:internal>AXAPTA</link:internal> 3.0 Разработка бизнес-приложений. Алексей Еременко, Руслан Шашков

стр 368

FirstFast - рекомендации оптимизатору выбрать первую запись, что может заставить оптимизатор производить поиск по порядку в соответствии с индексом, вне зависимости от условия where, то есть не используя подсказки оптимизатора;

FirstOnly - рекомендация оптимизатору выбрать первую запись, вне зависимости от того, сколько записей соответствует условию запроса.

==============================================

Далее уже от себя

Если говорить "по человечески", то FirstOnly возьмет только первую попавшуюся запись из результата выборки, а FirstOnly - ускорит получение первой записи, но может сильно затормозить получение всех остальных записей выборки.

FirstOnly - имеет смысл использовать, если необходимо получить одну и только одну запись, но в выборке может оказаться несколько записей. На скорость выборки никак не влияет. Это нечто вроде аналога конструкции SELECT TOP <link:internal>1</link:internal> ...

FirstFast - имеет смысл использовать, если результат выборки обрабатывается в цикле (while select), где каждая итерация цикла занимает относительно много времени. В этом случае, быстро получаем первую запись и начинаем ее обрабатывать, а скорость выборки остальных записей не так уж и важна, поскольку потеря в скорости "съедается" длительной обработкой одного шага цикла. Если в результирующей выборке только одна запись, то ее использование бессмысленно.

Теперь собственно вопрос: Ускорит ли совместное использование FisrtOnly и FirstFast получение одной и только одной записи, если в результирующей выборке может быть несколько записей?

На "вскидку" не скажу. Надо экспериментировать. Однако практика показывает, что "родные" оптимизаторы <link:internal>SQL</link:internal>-сервера, как правило, справляются с задачей оптимизации (ускорения) выборки значительно лучше, чем "ручное" указание что и как надо делать. А хинт FisrtFast - это и есть "ручное" указание. Т.е., в общем случае, его использование, скорее всего, приведет не к ускорению, а к замедлению получения выборки.

Кроме того, не вполне ясно, в какой именно момент FirstOnly сделает выбор единственной записи. При получении первой записи или после получения всех записей. Тоже надо бы проверить...

AndyD

2 Владимир Максимов

Во-первых, эти хинты зависят от сервера б/д
Во-вторых, от параметра CashLookup таблицы

Для <link:internal>MS SQL</link:internal>; CashLookup - EntireTable
При первом обращении на сервер отправляется запрос с хинтом OPTION(FAST n) (n - зависит от таблицы) и после этого записи фетчатся порциями по n, пока не будет закачана вся таблица (и для firstonly и для firstfast). При повтороном обрущении данные берутся из кэша

<link:internal>MS SQL</link:internal>; другие значения CashLookup
Для хинта firstonly
На сервер отправляется запрос с хинтом OPTION(FAST 2), после этого фетчится две записи и курсор закрывается
Для хинта firstfast
На сервер отправляется запрос с хинтом OPTION(FAST <link:internal>1</link:internal>) и после этого фетчится n записей (n - зависит от таблицы). Если записи перебирать в цикле, то при выборе n+<link:internal>1</link:internal> записи на сервер посылается запрос на фетч еще n записей и т.д.
Для совместного использования хинтов firstonly и firstfast
На сервер отправляется запрос с хинтом OPTION(FAST <link:internal>1</link:internal>) и после этого фетчится две записи и курсор закрывается
Если не использовать хинты]
На сервер отправляется запрос с хинтом OPTION(FAST n) и после этого фетчится n записей (n - зависит от таблицы). Если записи перебирать в цикле, то при выборе n+<link:internal>1</link:internal> записи на сервер посылается запрос на фетч еще n записей и т.д.

Для <link:internal>Oracle</link:internal> примерно то-же самое, отличие вот в чем: для EntireTable и если не указаны хинты посылается запрос как есть, для остальных значений CashLookup - хинт /+ <link:internal>FIRST_ROWS</link:internal> / (и для firstonly и firstfast).


2NetBus

Отвечая на первоначальный вопрос
Для <link:internal>MS SQL</link:internal>
использование совместно этих хинтов принципиального выигрыша в быстродействии не даст. При выборке больше чем одной записи - зависит от параметра n, т.е. от таблицы.

Для <link:internal>Oracle</link:internal>
совместное использование хинтов ничего не даст. В остальном -зависит от настройки оптимизатора, т.е. от параметра <link:internal>OPTIMIZER_MODE</link:internal> сервера или OPTIMIZER_GOAL сессии

Ладно, сделаю еще одну попытку.
И при выборке select firstonly firstfast и при select firstonly на клиента будет отфетчено 2 записи. Для MS-<link:internal>SQL</link:internal> отличие в хинте OPTION(FAST n), где n для первого случая = <link:internal>1</link:internal>, для второго 2. Для <link:internal>Oracle</link:internal> различий нет. В обоих случаях уходит хинт /+ <link:internal>FIRST_ROWS</link:internal>/

---

AndyD

Все нижеследующее имеет отношение только к работе с <link:internal>MS SQL</link:internal> Server

Давайте сначала определимся, что делает FAST

Цитата:
<link:internal>SQL</link:internal> Server Books Online
Specifies that the query is optimized for fast retrieval of the first number_rows (a nonnegative integer). After the first number_rows are returned, the query continues execution and produces its full result set.

Если в запросе присутствует этот хинт, то при получении первых n записей сервер вернет их клиенту и после этого продолжит выполнять запрос до получения оставшихся. Вот и все. Никаких ускорений и никаких замедлений. Предназначение хинта - отзывчивость приложения, т.е. клиент получит первые записи с максимальной скоростью, а затем будет ждать получения оставшихся.

В чем заключается оптимизация? Рассмотрим на примере InventTable (планы выполнения - во вложении).

PHP код:
select <link:internal>recid</link:internal> from InventTable order by dataareaid, itemgroupid

Что будет, если отослать этот запрос на сервер? Какой план запроса будет выбран?
Будет выбран кластерный индекс I_175ITEMIDX. Оптимизатор решил, что выбрать записи по нему, а затем отсортировать на сервере будет быстрее, чем использовать индекс по полям, учавствующим в сортировке. Но в этом случае для получения первой записи на клиенте необходимо получить все записи таблицы, отсортировать их и только после этого клиент получит то что запросил. При большом количестве записей ожидание выполнения запроса может занять десятки секунд.

PHP код:
select <link:internal>recid</link:internal> from InventTable order by dataareaid, itemgroupid option (fast 10)

Добавим хинт FAST. Теперь план исполнения изменился. Используется индекс по полям, участвующим в предложении ORDER BY (I_175GROUPITEMIDX). Первые записи могут быть получены сразу. На клиента отправляется 10 записей, а затем сервер, так же как и в первом случае, продолжает поиск записей, удовлетворяющих условию. Первые записи могут быть получены сразу, но общее время выполнения запроса может увеличиться.

В общем виде использование хинта FAST ведет вот к чему. Если существует индекс по полям, входящим в предложение ORDER BY, то будет использоваться этот индекс и мы получим первые записи насколько возможно быстро. Если нет, то будет использоваться индекс выбранный оптимизатором, а сортировка будет произведена на сервере. Получение записей будем ждать, пока запрос не будет выполнен полностью.

Так как <link:internal>Axapta</link:internal> использует хинт FAST во всех запросах, то, получается, что ORDER BY является недокументированной возможностью повлиять на выполнение запроса (по крайней мере мне не встречалась информация по этому поводу). А так же возможностью затормозить выполнение запроса по самое не балуйся.


Перейдем к рассмотрению работы самой <link:internal>Axapta</link:internal>'ы с <link:internal>SQL</link:internal> сервером.

А работает она с использованием семейства функций sp_cursor* jtds.sourceforge.net/apiCursors.<link:internal>html</link:internal>. При выполнении любого запроса (в том числе и используемого в DataSource) <link:internal>Axapta</link:internal> открывает на сервере курсор (курсор имеет тип Fast forward-only cursor). При этом может использоваться подготовка (prepare) запроса для дальнейшего многократного использования. Каждая функция принимает в качестве параметров тип курсора, вид <link:internal>блокировки</link:internal> и сам запрос (или его хэндл для prepared запросов). Функция открывает курсор, отдает запрос серверу и ожидает его выполнения. После получения ответа от сервера клиенту возвращается хэндл курсора. Дальше <link:internal>Axapta</link:internal> начинает фетчить записи на клиента (sp_cursorfetch). Записи, в основном, фетчатся группами (для ускорения выборки). После окончания обработки происходит закрытие курсора (sp_cursorclose), а так же для prepared запросов возможен вызов sp_cursorunprepare если необходимость в нем отпала.
У этого семейства функций есть одна осбенность, которая помогает <link:internal>Axapta</link:internal>'е минимизировать простои при выполнении запросов - все они возвращают управление в тот момент, когда вернет управление сервер. Т.е. при использовании хинта FAST мы получим хэндл курсора сразу после получения первых записей (тут необходимо учитывать то, что написано выше про FAST, т.е. могут быть <link:internal>запросы</link:internal>, которые в любом случае будут выполнены полностью). Дальнейшее продолжение запроса выполняется при фетче записей, причем каждый раз возвращается столько, сколько нам необходимо.

Теперь вернемся к предмету разговора - совместному использованию firstonly и firstfast.
Само выполнение запроса не ведет к возврату записей на клиента, т.е. даже не смотря на то, что при использовании firstfast в запросе передается FAST <link:internal>1</link:internal>, получим эти записи мы лишь при фетче - сервер выберет <link:internal>1</link:internal> уже уже найденную запись и продолжит поиск остальных записей группы. Т.е. реально время, потраченное на поиск и выборку записей будет и в том и в другом случае одинаковым.
Тут может возникнуть такое соображение - хорошо, но в случае открытия на обновление могут возникнуть <link:internal>блокировки</link:internal> и даже разница в одну запись может оказаться существенной. Но в данном случае <link:internal>Axapta</link:internal> ведет себя несколько иначе - при использовании хинта firstonly в запрос добавляется FAST <link:internal>1</link:internal>, а на клиента фетчится <link:internal>1</link:internal> запись.

Таким образом добавление firstfast в запрос с firstonly ничего не добавляет в плане производительности.

Использование firstfast отдельно имеет смысл только при открытии запроса на обновление, т.к. в этом случае при большой нагрузке на сервер возможен временной интервал м-ду открытием запроса (с одной записью) и фетчем записей на клиента (группы записей)


</note-content></text>
  <last-change-date>2010-03-21T18:14:01.2473340+03:00</last-change-date>
  <last-metadata-change-date>2010-03-21T18:14:01.2473340+03:00</last-metadata-change-date>
  <create-date>2008-03-28T15:05:07.9709050+03:00</create-date>
  <cursor-position>7749</cursor-position>
  <width>483</width>
  <height>360</height>
  <x>0</x>
  <y>0</y>
  <open-on-startup>False</open-on-startup>
</note>