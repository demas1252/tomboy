<?xml version="1.0" encoding="utf-8"?>
<note version="0.3" xmlns:link="http://beatniksoftware.com/tomboy/link" xmlns:size="http://beatniksoftware.com/tomboy/size" xmlns="http://beatniksoftware.com/tomboy">
  <title>новый механизм корреспондирования</title>
  <text xml:space="preserve"><note-content version="0.1">новый механизм корреспондирования


     Хотя с тех пор он несколько изменился, но принципиальный подход остался прежним: Используются скобки корреспондирования и лог корреспондирования. 
     
     Что такое скобки корреспондирования ? 
     Представим себе, что у нас есть отдельный кусок кода, который создает некий целостностный с экономической точки зрения набор постингов. Например – класс salesFormLetter_invoice создает внутри себя постинги на счета реализации и счет задолженности. Внутри этого класса происходит обращение (в конечном итоге) к методу inventUpdate.updateLedgerAdjustment , который создает постинги списания товара со складского счета на счет затрат периода. Также внутри класса salesFormLetter_invoice вызывается класс taxSalesInvoice, в котором создаются постинги создания задолженности по налогам и постинги расходов на налоги. 
     Если в старой версии, система в самом конце обработки пыталась откорреспондировать ВСЕ созданные постинги, то в новой версии – каждый из этих отдельных классов обладает способностью самостоятельно указывать режим корреспондирования созданных им постингов. При этом – класс разноски налогов не имеет никакого представления о том, чего происходит со списанием со склада или реализацией и задолженностью. Класс разноски списания со склада не имеет ни малейшего представления о том, чего именно случится с товаром после списания, будут ли с этой операции начислены какие-то налоги и тп.
     Фактически – в начале каждого из таких кусков кода происходит вызов некого метода- открывающей скобки корреспондирования(подробности позже), который создает внутри объекта <link:internal>ledgerVoucher</link:internal> протокол со списком созданных постингов.Все созданные после этого постинги попадают в данный протокол. В конце такого куска кода, система пробегается по созданному логу, и указывает какие из созданных постингов корреспондируют друг с другом. В конце куска кода производится вызов метода-закрывающей скобки корреспонденции, при котором происходит удаление лога. В случае использования вложенных скобок корреспонденции, постинги протоколируются как во внутреннем (вложенном) логе, так и во всех внешних (облегающих) логах корреспонденции. Но поскольку при обработке облегающего лога корреспонденции, система по умолчанию игнорирует уже откорреспондированные постинги, то внешний обработчик корреспонденции не натыкается на постинги созданные и обработанные во вложенном куске кода. Ну то есть – если попробовать записать в математическом виде последовательность вызовов из примера разноски накладной по заказу, то получится примерно следующее:

     1. Создается объект <link:internal>ledgerVoucher</link:internal> (
     2. (Для каждой строки накладной вызывается метод updateInventory, который с помощью классов inventMovement и inventUpd_financial создает проводки списания в таблице <link:internal>inventTrans</link:internal> и постинги списания по ГК)
     3. (Для каждой строки накладной со скидкой создается два постинга на сумму скидки)
     4. Для каждой строки накладной создается запись в таблице строк накладных (custInvoiceTrans)
     5. (Для каждой строки накладной создается (ну или не создается J ) запись и разноска по комиссии продавца.)
     6. Для каждой строки накладной разносится в ГК сумма выручки.
     7. (Для каждой строки накладной разносятся в ГК <link:internal>накладные расходы</link:internal> по данной строке)
     8. После того, как обработка всех построчных операций завершена, система рассчитывает общую сумму накладной
     9. Создается шапка накладной (custInvoiceJour)
     10. (Разносятся в ГК <link:internal>накладные расходы</link:internal>, не привязанные к строке накладной)
     11. (Разносятся в ГК и в таблицу проводок по налогам (taxTrans) налоги по заказу. )
     12. Разносится в ГК и в таблицу проводок по клиенту (custTrans) информация о клиентской задолженности.
     13. (Разносится в ГК общая скидка по накладной.)
     14.  ) Объект <link:internal>ledgerVoucher</link:internal> завершается вызовом метода end().

     Видно, что к моменту закрытия завершающей скобки корреспонденции в 14 пункте, у нас остались не откорреспондироваными только постинги реализации и постинги клиентской задолженности. Все остальные постинги уже были откорресподированы в соответствующих подсистемах.
     
     Хочу отметить, что разработчики расставили скобки корреспонденции и вызовы методов корреспондирования только для тех сочетаний постингов, которые имеют смысл с точки зрения российского учета. В принципе, если включить некоторые настройки, ориентированные на западный финансовый функционал, можно заставить систему генерировать такие постинги, для которых корреспондирование не отработает. В этом случае, в периодических операциях модуля ГК можно запросить список неоткорреспондированых постингов и откорреспондировать их в ручную.
</note-content></text>
  <last-change-date>2009-10-17T22:10:53.8278150+04:00</last-change-date>
  <last-metadata-change-date>2009-10-17T22:10:53.8278150+04:00</last-metadata-change-date>
  <create-date>2008-03-29T06:22:30.9733550+03:00</create-date>
  <cursor-position>585</cursor-position>
  <width>498</width>
  <height>360</height>
  <x>4</x>
  <y>437</y>
  <open-on-startup>False</open-on-startup>
</note>