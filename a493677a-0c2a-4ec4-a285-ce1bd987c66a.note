<?xml version="1.0" encoding="utf-8"?>
<note version="0.3" xmlns:link="http://beatniksoftware.com/tomboy/link" xmlns:size="http://beatniksoftware.com/tomboy/size" xmlns="http://beatniksoftware.com/tomboy">
  <title>ошибки округления и корректировки</title>
  <text xml:space="preserve"><note-content version="0.1">ошибки округления и корректировки


Представим себе следующую ситуацию: Допустим – мы закупили 3 единицы товара на общую сумму 10 рублей. Затем – каждую из этих единиц мы продали (отдельными заказами). Предположим также, что мы этот товар не переносили между складами и вообще никаких операций по нему кроме этой <link:internal>закупки</link:internal> и трех продаж, не выполняли. После закрытия склада – себестоимость списания по каждому из этих заказов будет равняться 33 рубля и 3 копейки. По приходу у нас возникнет интересная картина. Сопоставленное количество – будет равняться 3 (то есть – в общем-то, все списали и приходную проводку пора помечать как закрытую). В то же время – сопоставленная сумма будет равняться 9 рублям и 99 копейкам (то есть – приходную проводку нельзя помечать как закрытую, поскольку на проводке зависло сальдо в одну копейку). В подобной ситуации, система просто переоценит приходную проводку на одну копейку в корреспонденции с корсчетом прихода  со счетом прибылей и убытков из настроек складской разноски для склада. (Следует отметить – что для закупок, корсчетом прихода является счет потребления по закупке из настроек складских разносок). То есть – после закрытия склада – у нас в приходной проводке в поле costAmountPosted будет указана исходная сумма (10 рублей), а в costAmountAdjustment - -1 копейка, при этом сама приходная проводка будет помечена как закрытая.

В том случае, если у нас происходит списание прогоняемой коррекции себестоимости (либо потому что она меньше заданного при закрытии склада порога точности, либо потому что у нас исчерпался счетчик итераций), система поступает аналогичным образом.

Допустим – у нас с предыдущей итерации прогона себестоимости на данный приход по журналу спецификации пришла коррекция в 3 копейки, которая меньше чем наш порог точности закрытия (Параметр закрытия – "Минимальная коррекция пропускной способности”. Система сгенерирует сопоставление, корректирующее себестоимость прихода по журналу спецификации в корреспонденции с  корсчетом прихода на 3 копейки, а затем сразу же уценит этот приход на три копейки в корреспонденции со счетом прибылей и убытков.

Update: Уже после того как опубликовал статью - посмотрел как сделаны округления на 4ой версии. Картина следующая: в версии 4.0sp1 в метод initInventSettlement класса inventCostItemDim добавлен новый (последний) параметр _errorAdjustment, который выставляется в true, в том случае если этот метод вызывается из метода createErrorAdjustment, занимающегося списанием ошибок округления и корректировок при пригонке себестоимости. В  этом случае, в качестве коррсчета корректировки берется счет прибылей и убытков из настроек складской разноски для данной номенклатуры, а не коррсчет прихода, как обычно. В старой версии, в которой эта логика не была добавлена, списанные округления и корректировки зависали на коррсчетах прихода. Поскольку коррсчетов прихода в закрытии склада использовалось много, оценить и списать сумму ошибок при закрытии было нелегко. Поэтому, если вы работаете не более старых версиях, я рекомендую вам перенести эту доработку на ваше приложение. Кроме того, на мой взгляд, мысль списывать округление напрямую на счета прибылей и убытков тоже не очень удачная. Правильнее было бы накапливать сумму ошибок на каком-то выделенном счете, а потом, при трансформации баланса, закрывать этот счет в ручную. Для того чтобы добиться такого эффекта - необходимо подправить метод inventAdj::errorAccountOperation(), таким образом чтобы он возвращал нужный вам счет ошибок округления. Я бы, наверное, использовал  для этого счета отклонений от стандартной себестоимости. Если standard costing используется - то на эти счета как раз и нужно отклонения списывать, а если не используется - то эти счета в настройке складских разносок не заняты и их можно приспособить под списание ошибок и округлений. Если эта схема вам подходит - достаточно поменять в методе InventAdj::errorAccountOperation() значения InventAccountType::InventProfit и InventAccountType::InventLoss на InventAccountType::InventStdProfit и InventAccountType::InventStdLoss соответственно.</note-content></text>
  <last-change-date>2009-10-12T12:00:33.1866540+04:00</last-change-date>
  <last-metadata-change-date>2009-10-12T12:00:33.1866540+04:00</last-metadata-change-date>
  <create-date>2008-03-29T06:31:12.2193100+03:00</create-date>
  <cursor-position>62</cursor-position>
  <width>450</width>
  <height>360</height>
  <x>109</x>
  <y>49</y>
  <open-on-startup>False</open-on-startup>
</note>